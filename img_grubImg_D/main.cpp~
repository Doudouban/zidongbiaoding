//点云图是相机坐标，相机朝向为Z轴正方向
#include <limits>
#include <cassert>
#include <cmath>
#include <time.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/io.h>
#include "common/common.hpp"

using namespace std;
using namespace cv;

static char buffer[1024 * 1024];
static int  n;
static volatile bool exit_main;

bool has_Color = false;
static TY_CAMERA_INTRINSIC m_colorIntrinsic;
static int windows_size = 700;
bool save = false;

struct CallbackData
{
	int             index;
	TY_DEV_HANDLE   hDevice;
	DepthRender*    render;
	PointCloudViewer* pcviewer;
	int  fileIndex;
};

void frameHandler(TY_FRAME_DATA* frame, void* userdata)
{
	clock_t start_time = clock();
	CallbackData* pData = (CallbackData*)userdata;
	LOGD("=== Get frame %d", ++pData->index);

	Mat depth, p3d;
	parseFrame(*frame, &depth, 0, 0, 0, &p3d);

	clock_t get_time = clock();

	clock_t depth_start_time = clock();
	clock_t depth_show_time = 0;
	clock_t depth_store_time = 0;
	if (!depth.empty())
	{
		namedWindow("depth", CV_WINDOW_NORMAL);
		moveWindow("depth", 300 + windows_size, 0);
		resizeWindow("depth", windows_size, windows_size);
		imshow("depth", depth * 32);
		depth_show_time = clock();
		{
			char path_depth[32];
			sprintf(path_depth, "../data/depth/%d.png", pData->fileIndex);
			imwrite(path_depth, depth * 32);
		}
		depth_store_time = clock();
	}//若不保存深度图则隐去
	
	clock_t p3d_start_time = clock();
	clock_t p3d_show_time = 0;
	clock_t p3d_trans_time = 0;
	clock_t p3d_store_time = 0;
	if (!p3d.empty())
	{
		//pData->pcviewer->show(p3d, "Point3D");
		p3d_show_time = clock();
	//	{
	//		char path_pointcloud[32];
	//		sprintf(path_pointcloud, "../data/cloud/%d.txt", pData->fileIndex);
	//		writePointCloud((Point3f*)p3d.data, p3d.total(), path_pointcloud, PC_FILE_FORMAT_XYZ);
	//	}
		{
			int ds = 1;//降倍数存储
			int num = p3d.rows * p3d.cols / ds;
			pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
			Point3f *point_data = (Point3f*)p3d.data;
			for(int i = 0; i < num; i =( i + ds )){
            cloud->points.push_back(pcl::PointXYZ(point_data[i].x, point_data[i].y, point_data[i].z));
			}
			p3d_trans_time = clock();
			cloud->width =  cloud->points.size();
			cloud->height   = 1;
			cloud->is_dense = false;
			char path_pointcloud[32];
			sprintf(path_pointcloud, "../data/cloud_pcd/%d.pcd", pData->fileIndex);
			pcl::io::savePCDFile<pcl::PointXYZ> (path_pointcloud, *cloud);	
		}
		
		p3d_store_time = clock();
	}
	clock_t end_time = clock();
	pData -> fileIndex++;
	int key = waitKey(10);

	cout << "-------->" << endl;
	cout << "get_time " << get_time - start_time << " us" << endl;
	cout << "depth_show_time " << depth_show_time - depth_start_time << " us" << endl;
	cout << "depth_store_time " << depth_store_time - depth_show_time << " us" << endl;
	cout << "p3d_show_time " << p3d_show_time - p3d_start_time << " us" << endl;
	cout << "p3d_trans_time " << p3d_trans_time - p3d_show_time << " us" << endl;
	cout << "p3d_store_time " << p3d_store_time - p3d_trans_time << " us" << endl;
	cout << "all_time " << end_time - start_time << " us" << endl;
	LOGD("=== Callback: Re-enqueue buffer(%p, %d)", frame->userBuffer, frame->bufferSize);
	ASSERT_OK(TYEnqueueBuffer(pData->hDevice, frame->userBuffer, frame->bufferSize));
	cout << endl;
}

int main(int argc, char* argv[])
{
	const char* IP = NULL;
	const char* ID = NULL;
	const char* file = NULL;
	bool save3d = false;
	bool ir2jpg = false;
	TY_DEV_HANDLE hDevice;

	LOGD("=== Init lib");
	ASSERT_OK(TYInitLib());
	TY_VERSION_INFO* pVer = (TY_VERSION_INFO*)buffer;
	ASSERT_OK(TYLibVersion(pVer));
	LOGD("     - lib version: %d.%d.%d", pVer->major, pVer->minor, pVer->patch);

	{
		LOGD("=== Get device info");
		ASSERT_OK(TYGetDeviceNumber(&n));
		LOGD("     - device number %d", n);

		TY_DEVICE_BASE_INFO* pBaseInfo = (TY_DEVICE_BASE_INFO*)buffer;
		ASSERT_OK(TYGetDeviceList(pBaseInfo, 100, &n));

		if (n == 0)
		{
			LOGD("=== No device got");
			return -1;
		}

		LOGD("=== Open device 0");
		ASSERT_OK(TYOpenDevice(pBaseInfo[0].id, &hDevice));
	}

	LOGD("=== Configure components, open point3d cam");
	// int32_t componentIDs = TY_COMPONENT_POINT3D_CAM;
	int32_t componentIDs = TY_COMPONENT_POINT3D_CAM | TY_COMPONENT_RGB_CAM;
	ASSERT_OK(TYEnableComponents(hDevice, componentIDs));

	int err = TYGetStruct(hDevice, TY_COMPONENT_RGB_CAM, TY_STRUCT_CAM_INTRINSIC, (void*)&m_colorIntrinsic, sizeof(m_colorIntrinsic));
	if (err != TY_STATUS_OK)
	{
		LOGE("Get camera RGB intrinsic failed: %s", TYErrorString(err));
	}
	else
	{
		has_Color = true;
	}

	LOGD("=== Configure feature, set resolution to 640x480.");
	LOGD("Note: DM460 resolution feature is in component TY_COMPONENT_DEVICE,");
	LOGD("      other device may lays in some other components.");
	err = TYSetEnum(hDevice, TY_COMPONENT_DEPTH_CAM, TY_ENUM_IMAGE_MODE, TY_IMAGE_MODE_640x480);
	ASSERT(err == TY_STATUS_OK || err == TY_STATUS_NOT_PERMITTED);

	LOGD("=== Prepare image buffer");
	int32_t frameSize;
	ASSERT_OK(TYGetFrameBufferSize(hDevice, &frameSize));
	LOGD("     - Get size of framebuffer, %d", frameSize);
	ASSERT(frameSize >= 640 * 480 * 2);

	LOGD("     - Allocate & enqueue buffers");
	char* frameBuffer[2];
	frameBuffer[0] = new char[frameSize];
	frameBuffer[1] = new char[frameSize];
	LOGD("     - Enqueue buffer (%p, %d)", frameBuffer[0], frameSize);
	ASSERT_OK(TYEnqueueBuffer(hDevice, frameBuffer[0], frameSize));
	LOGD("     - Enqueue buffer (%p, %d)", frameBuffer[1], frameSize);
	ASSERT_OK(TYEnqueueBuffer(hDevice, frameBuffer[1], frameSize));

	LOGD("=== Register callback");
	LOGD("Note: Callback may block internal data receiving,");
	LOGD("      so that user should not do long time work in callback.");
	LOGD("      To avoid copying data, we pop the framebuffer from buffer queue and");
	LOGD("      give it back to user, user should call TYEnqueueBuffer to re-enqueue it.");
	DepthRender render;
	PointCloudViewer pcviewer;
	CallbackData cb_data;
	cb_data.index = 0;
	cb_data.hDevice = hDevice;
	cb_data.render = &render;
	cb_data.pcviewer = &pcviewer;
	//    cb_data.saveOneFramePoint3d = false;
	cb_data.fileIndex = 0;

	LOGD("=== Disable trigger mode");
	ASSERT_OK(TYSetBool(hDevice, TY_COMPONENT_DEVICE, TY_BOOL_TRIGGER_MODE, false));

	LOGD("=== Start capture");
	ASSERT_OK(TYStartCapture(hDevice));

	LOGD("=== While loop to fetch frame");
	exit_main = false;
	TY_FRAME_DATA frame;

	while (!exit_main)
	{
		int err = TYFetchFrame(hDevice, &frame, -1);
		if (err != TY_STATUS_OK)
		{
			LOGD("... Drop one frame");
			continue;
		}

		frameHandler(&frame, &cb_data);
	}


	ASSERT_OK(TYStopCapture(hDevice));
	ASSERT_OK(TYCloseDevice(hDevice));
	ASSERT_OK(TYDeinitLib());
	// MSLEEP(10); // sleep to ensure buffer is not used any more
	delete frameBuffer[0];
	delete frameBuffer[1];

	LOGD("=== Main done!");
	return 0;
}
